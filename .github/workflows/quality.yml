name: Quality Gate

on:
  pull_request:
  push:
    branches:
      - main
      - release/**
      - feature/**
      - features/**
      - user/**
      - users/**
      - hotfix/**

jobs:
  verify:
    runs-on: ubuntu-latest
    env:
      COVERAGE_THRESHOLD_LINE: 65
      COVERAGE_THRESHOLD_BRANCH: 50
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true
    outputs:
      tests_passed: ${{ steps.test_metrics.outputs.tests_passed }}
      tests_failed: ${{ steps.test_metrics.outputs.tests_failed }}
      tests_skipped: ${{ steps.test_metrics.outputs.tests_skipped }}
      tests_status: ${{ steps.test_metrics.outputs.tests_status }}
      coverage_line_pct: ${{ steps.coverage_metrics.outputs.coverage_line_pct }}
      coverage_branch_pct: ${{ steps.coverage_metrics.outputs.coverage_branch_pct }}
      coverage_line_threshold: ${{ steps.coverage_metrics.outputs.coverage_line_threshold }}
      coverage_branch_threshold: ${{ steps.coverage_metrics.outputs.coverage_branch_threshold }}
      coverage_line_status: ${{ steps.coverage_metrics.outputs.coverage_line_status }}
      coverage_branch_status: ${{ steps.coverage_metrics.outputs.coverage_branch_status }}
      package_count: ${{ steps.package_metrics.outputs.package_count }}
      package_versions: ${{ steps.package_metrics.outputs.package_versions }}
      package_status: ${{ steps.package_metrics.outputs.package_status }}
      deterministic_status: ${{ steps.deterministic.outputs.deterministic_status }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json

      - name: Restore
        run: dotnet restore Incursa.Core.slnx

      - name: Verify type specs are present
        shell: pwsh
        run: ./scripts/verify-type-specs.ps1

      - name: Verify formatting and analyzers
        id: format
        run: dotnet format --verify-no-changes Incursa.Core.slnx

      - name: Build (deterministic)
        id: build
        run: dotnet build Incursa.Core.slnx --no-restore --configuration Release -warnaserror -p:ContinuousIntegrationBuild=true

      - name: Test with coverage gate
        id: test_coverage
        run: |
          # Ratcheting baseline: increase these values toward long-term 85/85 as coverage expands.
          dotnet test Incursa.Core.slnx \
            --no-build \
            --configuration Release \
            --results-directory ./TestResults \
            --logger "trx;LogFileName=quality-tests.trx" \
            /p:CollectCoverage=true \
            /p:CoverletOutput=./TestResults/Coverage/ \
            /p:CoverletOutputFormat=cobertura \
            /p:Threshold=${COVERAGE_THRESHOLD_LINE}%2c${COVERAGE_THRESHOLD_BRANCH} \
            /p:ThresholdType=line%2cbranch \
            /p:ThresholdStat=total

      - name: Collect test metrics
        id: test_metrics
        if: always()
        shell: bash
        run: |
          trx_file="$(find TestResults -name quality-tests.trx | head -n1 || true)"
          if [[ -z "$trx_file" ]]; then
            trx_file="missing.trx"
          fi
          bash scripts/ci/collect-test-metrics.sh "$trx_file" artifacts/ci-metrics/quality/test.json "$GITHUB_OUTPUT"

      - name: Create coverage summary
        if: always()
        run: |
          dotnet tool install --tool-path .tools dotnet-reportgenerator-globaltool --version 5.*
          ./.tools/reportgenerator \
            "-reports:**/coverage.cobertura.xml" \
            "-targetdir:artifacts/coverage-report" \
            "-reporttypes:HtmlInline;MarkdownSummaryGithub"

      - name: Collect coverage metrics
        id: coverage_metrics
        if: always()
        shell: bash
        run: |
          coverage_file="$(find . -name coverage.cobertura.xml | head -n1 || true)"
          if [[ -z "$coverage_file" ]]; then
            coverage_file="missing.xml"
          fi
          bash scripts/ci/collect-coverage-metrics.sh "$coverage_file" "$COVERAGE_THRESHOLD_LINE" "$COVERAGE_THRESHOLD_BRANCH" artifacts/ci-metrics/quality/coverage.json "$GITHUB_OUTPUT"

      - name: Upload coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: artifacts/coverage-report

      - name: Pack (repro 1)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf artifacts/repro1 artifacts/repro2
          mkdir -p artifacts/repro1 artifacts/repro2

          dotnet pack ./Incursa.Core.slnx \
            -c Release \
            -p:ContinuousIntegrationBuild=true \
            -p:Deterministic=true \
            -p:EmbedUntrackedSources=true \
            -p:PackageVersion=0.0.1-ci \
            -o artifacts/repro1 \
            --no-restore

      - name: Pack (repro 2)
        shell: bash
        run: |
          set -euo pipefail
          dotnet pack ./Incursa.Core.slnx \
            -c Release \
            -p:ContinuousIntegrationBuild=true \
            -p:Deterministic=true \
            -p:EmbedUntrackedSources=true \
            -p:PackageVersion=0.0.1-ci \
            -o artifacts/repro2 \
            --no-restore

      - name: Compare nupkg contents (normalized, multi-package)
        id: compare
        shell: bash
        run: |
          set -euo pipefail

          normalize_manifest() {
            local nupkg="$1"
            local out="$2"
            local dir
            dir="$(mktemp -d)"

            unzip -q "$nupkg" -d "$dir"
            rm -f "$dir/_rels/.rels" || true
            rm -f "$dir/package/services/metadata/core-properties/"*.psmdcp || true
            (
              cd "$dir"
              find . -type f -print0 | sort -z | xargs -0 sha256sum
            ) > "$out"
            rm -rf "$dir"
          }

          compare_packages() {
            local p1="$1"
            local p2="$2"
            local name="$3"
            local m1="/tmp/${name}.repro1.manifest"
            local m2="/tmp/${name}.repro2.manifest"

            normalize_manifest "$p1" "$m1"
            normalize_manifest "$p2" "$m2"

            if ! diff -u "$m1" "$m2" >/tmp/${name}.diff; then
              echo "::group::‚ùå Package differs (normalized): $name"
              echo "repro1: $p1"
              echo "repro2: $p2"
              cat "/tmp/${name}.diff"
              echo "::endgroup::"
              return 1
            fi
            echo "‚úÖ Deterministic (normalized): $name"
          }

          mkdir -p /tmp/nupkg-diff
          mapfile -t P1 < <(ls -1 artifacts/repro1/*.nupkg 2>/dev/null | sort)
          mapfile -t P2 < <(ls -1 artifacts/repro2/*.nupkg 2>/dev/null | sort)

          if [[ "${#P1[@]}" -eq 0 || "${#P2[@]}" -eq 0 ]]; then
            echo "No .nupkg files found in one or both directories."
            exit 1
          fi

          printf "%s\n" "${P1[@]##*/}" | sort > /tmp/repro1.names
          printf "%s\n" "${P2[@]##*/}" | sort > /tmp/repro2.names

          if ! diff -u /tmp/repro1.names /tmp/repro2.names >/tmp/nupkg-names.diff; then
            echo "::group::‚ùå Package sets differ between repro1 and repro2"
            cat /tmp/nupkg-names.diff
            echo "::endgroup::"
            exit 1
          fi

          declare -A MAP1 MAP2
          for p in "${P1[@]}"; do MAP1["$(basename "$p")"]="$p"; done
          for p in "${P2[@]}"; do MAP2["$(basename "$p")"]="$p"; done

          failed=0
          while IFS= read -r name; do
            if ! compare_packages "${MAP1[$name]}" "${MAP2[$name]}" "$name"; then
              failed=1
            fi
          done < /tmp/repro1.names

          if [[ "$failed" -ne 0 ]]; then
            echo "One or more packages were not deterministic (normalized)."
            exit 1
          fi

      - name: Export deterministic packaging status
        id: deterministic
        if: always()
        shell: bash
        env:
          COMPARE_OUTCOME: ${{ steps.compare.outcome }}
        run: |
          if [[ "$COMPARE_OUTCOME" == "success" ]]; then
            echo "deterministic_status=‚úÖ" >> "$GITHUB_OUTPUT"
          else
            echo "deterministic_status=‚ùå" >> "$GITHUB_OUTPUT"
          fi

      - name: Collect packaging metrics
        id: package_metrics
        if: always()
        shell: bash
        run: |
          bash scripts/ci/collect-package-metrics.sh artifacts/repro1 artifacts/ci-metrics/quality/packages.json "$GITHUB_OUTPUT"

      - name: Upload normalized package diffs
        if: failure() && steps.compare.outcome == 'failure'
        uses: actions/upload-artifact@v4
        with:
          name: nupkg-normalized-diffs
          path: |
            /tmp/*.manifest
            /tmp/*.diff
            /tmp/repro1.names
            /tmp/repro2.names
            /tmp/nupkg-names.diff

      - name: Upload verify metrics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: quality-verify-metrics
          path: artifacts/ci-metrics/quality

  mutation:
    name: Mutation Testing (Stryker)
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: verify
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'
    outputs:
      mutation_score: ${{ steps.mutation_metrics.outputs.mutation_score }}
      mutation_threshold: ${{ steps.mutation_metrics.outputs.mutation_threshold }}
      mutation_killed: ${{ steps.mutation_metrics.outputs.mutation_killed }}
      mutation_survived: ${{ steps.mutation_metrics.outputs.mutation_survived }}
      mutation_no_coverage: ${{ steps.mutation_metrics.outputs.mutation_no_coverage }}
      mutation_status: ${{ steps.mutation_metrics.outputs.mutation_status }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json

      - name: Restore
        run: dotnet restore Incursa.Core.slnx

      - name: Install Stryker
        run: dotnet tool install --tool-path .tools dotnet-stryker --version 4.9.0

      - name: Run mutation tests
        id: stryker
        run: |
          ./.tools/dotnet-stryker \
            -p Incursa.Types/Incursa.Types.csproj \
            -tp Incursa.Types.Tests/Incursa.Types.Tests.csproj \
            -l Basic \
            -L \
            -m "**/Money.cs" \
            -m "**/JsonContext.cs" \
            -m "**/MonthOnly.cs" \
            -m "**/Percentage.cs" \
            -m "**/TimeZoneId.cs" \
            -b 35 \
            --threshold-low 35 \
            --threshold-high 55 \
            --break-on-initial-test-failure \
            -r Progress \
            -r Html \
            -r Markdown \
            -O artifacts/stryker \
            --skip-version-check

      - name: Collect mutation metrics
        id: mutation_metrics
        if: always()
        shell: bash
        run: |
          bash scripts/ci/collect-mutation-metrics.sh artifacts/stryker artifacts/ci-metrics/quality/mutation.json "$GITHUB_OUTPUT"

      - name: Upload mutation artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: mutation-report
          path: artifacts/stryker

      - name: Upload mutation metrics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: quality-mutation-metrics
          path: artifacts/ci-metrics/quality/mutation.json

  report:
    name: Quality Report
    runs-on: ubuntu-latest
    if: always()
    needs: [verify, mutation]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Render quality summary
        shell: bash
        env:
          VERIFY_RESULT: ${{ needs.verify.result }}
          MUTATION_RESULT: ${{ needs.mutation.result }}
          TESTS_PASSED: ${{ needs.verify.outputs.tests_passed }}
          TESTS_FAILED: ${{ needs.verify.outputs.tests_failed }}
          TESTS_SKIPPED: ${{ needs.verify.outputs.tests_skipped }}
          TESTS_STATUS: ${{ needs.verify.outputs.tests_status }}
          COVERAGE_LINE_PCT: ${{ needs.verify.outputs.coverage_line_pct }}
          COVERAGE_BRANCH_PCT: ${{ needs.verify.outputs.coverage_branch_pct }}
          COVERAGE_LINE_THRESHOLD: ${{ needs.verify.outputs.coverage_line_threshold }}
          COVERAGE_BRANCH_THRESHOLD: ${{ needs.verify.outputs.coverage_branch_threshold }}
          COVERAGE_LINE_STATUS: ${{ needs.verify.outputs.coverage_line_status }}
          COVERAGE_BRANCH_STATUS: ${{ needs.verify.outputs.coverage_branch_status }}
          PACKAGE_COUNT: ${{ needs.verify.outputs.package_count }}
          PACKAGE_VERSIONS: ${{ needs.verify.outputs.package_versions }}
          PACKAGE_STATUS: ${{ needs.verify.outputs.package_status }}
          DETERMINISTIC_STATUS: ${{ needs.verify.outputs.deterministic_status }}
          MUTATION_SCORE: ${{ needs.mutation.outputs.mutation_score }}
          MUTATION_THRESHOLD: ${{ needs.mutation.outputs.mutation_threshold }}
          MUTATION_STATUS: ${{ needs.mutation.outputs.mutation_status }}
          MUTATION_KILLED: ${{ needs.mutation.outputs.mutation_killed }}
          MUTATION_SURVIVED: ${{ needs.mutation.outputs.mutation_survived }}
          MUTATION_NO_COVERAGE: ${{ needs.mutation.outputs.mutation_no_coverage }}
        run: |
          tests_failed="${TESTS_FAILED:-0}"
          tests_status="${TESTS_STATUS:-‚ùå}"
          if [[ "$tests_failed" != "0" ]]; then tests_status="‚ùå"; fi
          if [[ -z "${TESTS_PASSED:-}" ]]; then tests_status="‚ùå"; fi

          line_status="${COVERAGE_LINE_STATUS:-‚ùå}"
          branch_status="${COVERAGE_BRANCH_STATUS:-‚ùå}"
          package_status="${PACKAGE_STATUS:-‚ùå}"
          deterministic_status="${DETERMINISTIC_STATUS:-‚ùå}"

          mutation_status="‚ö†Ô∏è"
          mutation_metric="not run"
          mutation_threshold=">= 35"
          mutation_notes="job skipped"
          if [[ "$MUTATION_RESULT" == "success" ]]; then
            mutation_status="${MUTATION_STATUS:-‚ùå}"
            mutation_metric="${MUTATION_SCORE:-0}% killed"
            mutation_threshold=">= ${MUTATION_THRESHOLD:-35}%"
            mutation_notes="Killed ${MUTATION_KILLED:-0}; Survived ${MUTATION_SURVIVED:-0}; NoCoverage ${MUTATION_NO_COVERAGE:-0}"
          elif [[ "$MUTATION_RESULT" == "failure" ]]; then
            mutation_status="‚ùå"
            mutation_notes="mutation job failed"
          fi

          overall="‚úÖ Passed"
          if [[ "$VERIFY_RESULT" != "success" ]]; then overall="‚ùå Failed"; fi
          if [[ "$line_status" != "‚úÖ" || "$branch_status" != "‚úÖ" ]]; then overall="‚ùå Failed"; fi
          if [[ "$tests_status" != "‚úÖ" ]]; then overall="‚ùå Failed"; fi
          if [[ "$package_status" != "‚úÖ" || "$deterministic_status" != "‚úÖ" ]]; then overall="‚ùå Failed"; fi
          if [[ "$MUTATION_RESULT" == "failure" || "$mutation_status" == "‚ùå" ]]; then overall="‚ùå Failed"; fi

          gate_rows=""
          gate_rows+="| üß™ Tests | ${tests_status} | ${TESTS_PASSED:-0} pass / ${tests_failed} fail / ${TESTS_SKIPPED:-0} skipped | 0 fails | ${VERIFY_RESULT} verify job |\n"
          gate_rows+="| üìä Coverage (Line) | ${line_status} | ${COVERAGE_LINE_PCT:-0}% | >= ${COVERAGE_LINE_THRESHOLD:-65}% | Branch ${COVERAGE_BRANCH_PCT:-0}% |\n"
          gate_rows+="| üìä Coverage (Branch) | ${branch_status} | ${COVERAGE_BRANCH_PCT:-0}% | >= ${COVERAGE_BRANCH_THRESHOLD:-50}% | Line ${COVERAGE_LINE_PCT:-0}% |\n"
          gate_rows+="| üì¶ Packaging | ${package_status} | ${PACKAGE_COUNT:-0} packages | >= 1 | ${PACKAGE_VERSIONS:-metrics missing} |\n"
          gate_rows+="| üì¶ Determinism | ${deterministic_status} | normalized package compare | pass | reproducible pack check |\n"
          gate_rows+="| üß¨ Mutation | ${mutation_status} | ${mutation_metric} | ${mutation_threshold} | ${mutation_notes} |"

          artifact_rows="- \`coverage-report\` (coverage HTML + markdown)\n"
          artifact_rows+="- \`quality-verify-metrics\` (tests/coverage/package JSON)\n"
          artifact_rows+="- \`mutation-report\` and \`quality-mutation-metrics\`\n"
          artifact_rows+="- \`nupkg-normalized-diffs\` (on determinism failure)"

          actions=""
          if [[ "$overall" != "‚úÖ Passed" ]]; then
            actions="- Check failed gate rows above and open the corresponding artifact first.\n"
            actions+="- For coverage failures, inspect \`coverage-report\`.\n"
            actions+="- For mutation failures, inspect \`mutation-report\`."
          fi

          SUMMARY_TITLE="CI Quality Summary" \
          SUMMARY_RESULT="$overall" \
          SUMMARY_GATE_ROWS="$gate_rows" \
          SUMMARY_ARTIFACT_ROWS="$artifact_rows" \
          SUMMARY_ACTIONS="$actions" \
          bash scripts/ci/render-workflow-summary.sh
